###############################
# Heston CTMC + GP Pricing – Refactor (Julia)
# -------------------------------------------
# This script cleans up and corrects the original prototype. It provides:
#   1) A consistent Heston parameterization
#   2) Construction of a CTMC generator for the CIR variance (MCAM-style tridiagonal)
#   3) Exact CTMC simulation of the variance path from a generator Q
#   4) Gaussian–Projection (GP) conditional moments given the variance path
#   5) Path–wise Black–Scholes pricing kernel and Monte Carlo outer expectation
#   6) A robust Andersen–QE Heston simulator (optional) for cross‑checking
#
# Conventions (canonical Heston):
#   dS_t = r S_t dt + sqrt(V_t) S_t dW_t^{(1)}
#   dV_t = kappa*(theta - V_t) dt + xi*sqrt(V_t) dW_t^{(2)}
#   corr(dW^{(1)}, dW^{(2)}) = rho
#
# GP conditional moments (canonical, conditioning on sigma-algebra generated by V):
#   Let J_t := ∫_0^t V_s ds and ΔV_t := V_t - V_0. Then
#   mu_GP   = (r - rho*kappa*theta/xi) * t + (rho*kappa/xi - 1/2) * J_t + (rho/xi) * ΔV_t
#   sig2_GP = (1 - rho^2) * J_t
# These are the standard identities obtained by substituting dW^{(2)} via the V SDE.
# If you prefer the alternative placement of parameters used in your manuscript
# (with 1/kappa instead of 1/xi), set `use_user_notation=true` in `gp_params`.
###############################

using Random
using Distributions
using StatsBase
using LinearAlgebra
using Parameters
using Revise

# =============================
# 1) Parameters
# =============================
@with_kw mutable struct HestonParams
    S0::Float64 = 100.0   # initial spot
    r::Float64  = 0.02    # risk‑free rate (risk‑neutral drift of S)
    eff_mu::Float64 = 0.0 # effective drift of S under risk‑neutral measure
    kappa::Float64 = 6.21 # mean reversion speed for variance
    theta::Float64 = 0.04 # long‑run mean variance
    xi::Float64    = 0.50 # vol‑of‑vol (ξ)
    rho::Float64   = -0.7 # correlation
    v0::Float64    = 0.04 # initial variance
end

# Helpers for CIR drift/diffusion
cir_drift(v, p::HestonParams) = p.kappa*(p.theta - v)
cir_sigma(v, p::HestonParams) = p.xi*sqrt(max(v, 0.0))

# =============================
# 2) MCAM‑style CTMC generator for CIR on a grid
# =============================
"""
construct_generator_CIR(v::Vector, p; reflect_left=true, reflect_right=true)
  Build a tridiagonal generator Q on an arbitrary increasing grid v[1..m].
  Interior nodes use the MCAM finite‑difference stencil ensuring row‑sum zero
  and nonnegative off‑diagonals under mild grid conditions.

Notes:
  • v must be strictly increasing and contained in (0, ∞).
  • Reflection at boundaries is implemented via one‑sided stencils.
  • Returns Q::Matrix{Float64}, size m×m, with rows summing to 0.
"""
function construct_generator_CIR(v::Vector{Float64}, p::HestonParams;
                                reflect_left::Bool=true, reflect_right::Bool=true, tolerance::Float64=1e-10)
    m = length(v)
    @assert m ≥ 3 "Need at least 3 grid points"
    @assert all(diff(v) .> 0) "Grid must be strictly increasing"

    Q = zeros(m, m)
    h = diff(v)  # h[i] = v[i+1] - v[i]

    μ⁺(x) = max(cir_drift(x, p), 0.0)
    μ⁻(x) = max(-cir_drift(x, p), 0.0)
    σ²(x) = cir_sigma(x, p)^2

    # Interior points i = 2..m-1
    for i in 2:m-1
        hL, hR = h[i-1], h[i]
        mp, mm = μ⁺(v[i]), μ⁻(v[i])
        s2 = σ²(v[i])
        # MCAM / local‑generator stencil
        qL = mm/hL + (s2 - (hL*mm + hR*mp)) / (hL*(hL + hR))
        qR = mp/hR + (s2 - (hL*mm + hR*mp)) / (hR*(hL + hR))
        # Guard small negatives that can occur on pathological grids
        qL = max(qL, 0.0)
        qR = max(qR, 0.0)
        Q[i, i-1] = qL
        Q[i, i+1] = qR
        Q[i, i]   = -(qL + qR)
    end

    # Left boundary i=1
    if reflect_left
        hR = h[1]
        mp, s2 = μ⁺(v[1]), σ²(v[1])
        qR = mp/hR + s2/(hR^2)
        qR = max(qR, 0.0)
        Q[1,2] = qR
        Q[1,1] = -qR
    else
        # absorbing at left
        Q[1,1] = 0.0
    end

    # Right boundary i=m
    if reflect_right
        hL = h[end]
        mm, s2 = μ⁻(v[end]), σ²(v[end])
        qL = mm/hL + s2/(hL^2)
        qL = max(qL, 0.0)
        Q[m,m-1] = qL
        Q[m,m]= -qL
    else
        Q[m,m] = 0.0
    end

    # Sanity: rows sum ~ 0
    @assert maximum(abs.(sum(Q, dims=2))) ≤ tolerance "Row sums not ~ 0; check grid/stencil"
    return Q
end

# For different levels of 

# =============================
# 3) Exact CTMC simulation from generator Q
# =============================
"""
simulate_ctmc(Q, grid, T; v0)
  Simulate a piecewise‑constant variance path V_t on [0,T] governed by Q.
  Returns (states, times), where times[1]=0, times[end]=T and states[k] is
  the index of grid value held on [times[k], times[k+1]).
"""
function simulate_ctmc(Q::AbstractMatrix{<:Real}, grid::AbstractVector{<:Real}, T::Real; v0::Real)
    m = size(Q,1)
    @assert size(Q,2) == m "Q must be square"
    @assert length(grid) == m "grid length must match Q"
    # initialise index to nearest grid point
    i = argmin(abs.(grid .- v0))
    t = 0.0
    states = Int[i]
    times  = Float64[0.0]
    while t < T
        λ = -Q[i,i]
        if λ ≤ 0
            # no outgoing rate: stay here until T
            push!(times, T)
            break
        end
        τ = rand(Exponential(λ))
        if t + τ ≥ T
            push!(times, T)
            break
        end
        # choose next state j ≠ i with probabilities p_ij = Q_ij / λ
        probs = max.(Q[i, :], 0.0)
        probs[i] = 0.0
        s = sum(probs)
        @assert s > 0 "Row has no positive off‑diagonal rates"
        probs ./= s
        j = sample(1:m, Weights(probs))
        t += τ
        push!(times, t)
        push!(states, j)
        i = j
    end
    return states, times
end

# Utility: compute J = ∫ V_s ds and ΔV along CTMC path
function path_stats(states::Vector{Int}, times::Vector{Float64}, grid::Vector{Float64})
    @assert length(states) == length(times)-1 || length(states) == length(times)  # accept either convention
    # ensure segment‑wise representation: states[k] on [times[k], times[k+1])
    if length(states) == length(times)
        # last time should be T; we ignore trailing state beyond T
        states = states[1:end-1]
    end
    J = 0.0
    for k in 1:length(states)
        Δt = times[k+1] - times[k]
        J += grid[states[k]] * Δt
    end
    ΔV = grid[states[end]] - grid[states[1]]
    T  = times[end] - times[1]
    return J, ΔV, T
end

# =============================
# 4) Gaussian‑Projection conditional moments and BS kernel
# =============================
"""
gp_params(J::Real, ΔV::Real, T::Real, p::HestonParams; use_user_notation::Bool=false)
  Return (mu_GP, sig2_GP) given integrated variance J, variance change ΔV, horizon T.
  If `use_user_notation=true`, use the alternative form: replace xi↔kappa in the denominators
  to mirror the manuscript’s symbols.
"""
function gp_params(J::Real, ΔV::Real, T::Real, p::HestonParams; use_user_notation::Bool=false)
    if use_user_notation
        # User manuscript form (as given in earlier notes):
        μ = (p.eff_mu - p.rho * p.theta / p.kappa) * T + (p.rho * p.xi / p.kappa - 0.5) * J + (p.rho / p.kappa) * ΔV
        # NB: this line interprets manuscript symbols heuristically; prefer canonical form below.
    else
        # Canonical Heston GP moments
        μ = (p.eff_mu - (p.rho * p.kappa * p.theta) / p.xi) * T + ((p.rho * p.kappa)/p.xi - 0.5) * J + (p.rho / p.xi) * ΔV
    end
    σ2 = (1 - p.rho^2) * J
    return μ, σ2
end

"""
bs_call_kernel(S0::Real, K::Real, r::Real, μ::Real, σ2::Real)
  Path‑wise Black–Scholes price when log(S_T/S_0)| mathcal{G} ~ N(μ, σ2).
  Risk‑neutral identity implies e^{μ + 0.5 σ2} = e^{r T} and cancels.
"""
function bs_call_kernel(S0::Real, K::Real, r::Real, eff_mu::Real, σ2::Real, T::Real)
    σ = sqrt(max(σ2, 0.0))
    @assert σ > 0 "Zero conditional variance: handle separately"
    d1 = (log(S0/K) + eff_mu*T + 0.5*σ2) / σ
    d2 = d1 - σ
    Φ = cdf.(Normal(), [d1, d2])
    return S0*Φ[1] - K*exp(-r*T)*Φ[2]
end

function bs_put_kernel(S0::Real, K::Real, r::Real, eff_mu::Real, σ2::Real, T::Real)
    σ = sqrt(max(σ2, 0.0))
    @assert σ > 0 "Zero conditional variance: handle separately"
    d1 = (log(S0/K) + eff_mu*T + 0.5*σ2) / σ
    d2 = d1 - σ
    Φ = cdf.(Normal(), [-d1, -d2])
    return K*exp(-r*T)*Φ[1] - S0*Φ[2]
end
# Wrapper: price via CTMC outer expectation over many variance paths
function price_heston_ctmc_mc(p::HestonParams, vgrid::Vector{Float64}, Q::Matrix{Float64},
                              T::Float64, K::Float64; npaths::Int=50_000,
                              use_user_notation::Bool=false, rng::AbstractRNG=Random.GLOBAL_RNG)
    S0, r = p.S0, p.r
    acc = 0.0
    @inbounds for _ in 1:npaths
        states, times = simulate_ctmc(Q, vgrid, T; v0=p.v0)
        J, ΔV, _ = path_stats(states, times, vgrid)
        eff_μ, σ2 = gp_params(J, ΔV, T, p; use_user_notation)
        acc += bs_call_kernel(S0, K, r, eff_μ, σ2, T)
    end
    return acc / npaths
end

# =============================
# 5) Optional: Andersen–QE Heston simulator (for cross‑checks)
# =============================
# Returns terminal (S_T, V_T) or full paths if path=true.
function simulate_heston_QE(p::HestonParams, T::Float64; nsteps::Int=252, npaths::Int=10000, path::Bool=false)
    Δt = T/nsteps
    S = fill(p.S0, npaths)
    V = fill(p.v0, npaths)
    ρ, κ, θ, ξ, r = p.rho, p.kappa, p.theta, p.xi, p.r
    W1 = randn(npaths)
    W2 = randn(npaths)
    Z2 = W2
    Z1 = ρ*Z2 .+ sqrt(1-ρ^2)*W1

    if path
        S_path = zeros(npaths, nsteps+1); S_path[:,1] .= p.S0
        V_path = zeros(npaths, nsteps+1); V_path[:,1] .= p.v0
    end

    for n in 1:nsteps
        # QE variance step (Andersen 2008)
        m = @. θ + (V - θ)*exp(-κ*Δt)
        s2 = @. (V*ξ^2) * exp(-κ*Δt) * (1 - exp(-κ*Δt)) / κ + θ*ξ^2*(1 - exp(-κ*Δt))^2/(2κ)
        psi = @. s2 / (m^2)
        Vnew = similar(V)
        for i in eachindex(V)
            if psi[i] ≤ 1.5
                b2 = 2/psi[i] - 1 + sqrt(2/psi[i]) * sqrt(2/psi[i] - 1)
                a  = m[i] / (1 + b2)
                Vnew[i] = a * (sqrt(b2) + Z2[i])^2
            else
                pexp = (psi[i] - 1)/(psi[i] + 1)
                β    = (1 - pexp)/m[i]
                if rand() ≤ pexp
                    Vnew[i] = 0.0
                else
                    Vnew[i] = rand(Exponential(β))
                end
            end
        end
        # Correlated GBM step (log S)
        S .*= @. exp((r - 0.5*V)*Δt + sqrt(V*Δt)*Z1)
        V .= Vnew
        if path
            S_path[:,n+1] .= S
            V_path[:,n+1] .= V
        end
        # refresh normals for next step
        W1 .= randn(npaths); W2 .= randn(npaths); Z2 .= W2; Z1 .= ρ*Z2 .+ sqrt(1-ρ^2)*W1
    end
    if path
        return S_path, V_path
    else
        return S, V
    end
end

# =============================
# 6) Minimal example / sanity check
# =============================

Random.seed!(42)
p = HestonParams()

# Build grid and generator
"""
Choice of the grid is important for the CTMC generator. Choosing a grid that does not
capture the low and high tail behaviour of the CIR process can lead to numerical issues.
Here, we use a grid that spans a reasonable range of variances, ensuring the generator
is well‑behaved and captures the dynamics of the Heston model.
The grid is uniformaly space in [vmin, vmax] with m points.
Ideally, as seen in Mijaljovic and Pistorius, the grid spacing performs well whe it is non-uniformly spaced, 
but for simplicity of analysis, we use a uniform grid here.
"""

vmin, vmax, m = 1e-2, 100.0, 10_000

vgrid = collect(range(vmin, vmax, length=m))
Q = construct_generator_CIR(vgrid, p)
@info "Q shape" size(Q)
@info "Row sums (∞‑norm) ~ 0" maximum(abs.(sum(Q, dims=2)))

# Price by CTMC outer expectation
T, K = 1.0, 100.0
price_mc = price_heston_ctmc_mc(p, vgrid, Q, T, K; npaths=10000)
price_mc_single_path = price_heston_ctmc_mc(p, vgrid, Q, T, K; npaths=1)
@info "CTMC‑GP price (MC outer expectation)" price_mc

# Cross‑check: Andersen–QE Monte‑Carlo (plain payoff)
nsteps = 252; npaths = 20000
ST, _ = simulate_heston_QE(p, T; nsteps=nsteps, npaths=npaths, path=false)
payoff = max.(ST .- K, 0.0)
price_qe = exp(-p.r*T) * mean(payoff)
@info "Andersen‑QE MC price" price_qe


println("Heston CTMC + GP Pricing script loaded successfully.")
println(@__FILE__)

PS_Cui = HestonParams(S0=10.0, r=0.0, eff_mu=0, kappa=4.0, theta=0.035, xi=0.15, rho=-0.75, v0=0.04)
T = 1.0
K = 4.0

v_min, v_max, m = 1e-3 * PS_Cui.v0, 4.0 * PS_Cui.v0, 1000
vgrid = collect(range(v_min, v_max, length=m))
Q = construct_generator_CIR(vgrid, PS_Cui)
@info "Q shape" size(Q)
@info "Row sums (∞‑norm) ~ 0" maximum(abs.(sum(Q, dims=2)))

price_mc_cui = price_heston_ctmc_mc(PS_Cui, vgrid, Q, T, K, npaths=10)


# Now, change the values of N so that I can plot the convergence rates of the European option price
Baseline_price = 6.0000
# N_values = [30,40,50,60,70,80,90,100,125,150,175,200,250]
grid_sizes = [5, 10, 20, 40, 80, 160]
path_lengths = [1, 5, 10, 15, 20, 100, 200, 500, 1000, 2000, 5000, 10000]
# Log errors for each combination of grid size and path length
errors = Dict{Tuple{Int, Int}, Float64}()
for N in grid_sizes
    for npaths in path_lengths
        v_min, v_max = 1e-3 * PS_Cui.v0, 4.0 * PS_Cui.v0
        vgrid = collect(range(v_min, v_max, length=N))
        Q = construct_generator_CIR(vgrid, PS_Cui; tolerance=1e-5)
        price_mc = price_heston_ctmc_mc(PS_Cui, vgrid, Q, T, K; npaths=npaths)
        @info "Computed price for N=$(N), npaths=$(npaths): $(price_mc)"
        errors[(N, npaths)] = abs(price_mc - Baseline_price)
    end
end
println("Errors computed for different grid sizes and path lengths.")
@info "Errors: $(errors)"
function convergence_rate(errors::Dict{Tuple{Int, Int}, Float64}, N_values::Vector{Int}, path_lengths::Vector{Int})
    # rates = Float64[]
    # Log the rate of convergence for the pair of (N, npaths)
    rates = Dict{Tuple{Int, Int}, Float64}()
    @info "Errors length: $(length(errors))"
    for i in 2:length(N_values)
        for npaths in path_lengths
            rate = log(errors[(N_values[i-1], npaths)] / errors[(N_values[i], npaths)]) / log(N_values[i-1] / N_values[i])
            @info "Convergence rate for N=$(N_values[i]) and npaths=$(npaths): $(rate)"
            rates[(N_values[i], npaths)] = rate
        end
    end
    return rates
end

# Plot the convergence rates
using Plots
@info "Errors length: $(length(errors))"

rates = convergence_rate(errors, grid_sizes, path_lengths)
# plot(N_values[2:end], rates, xlabel="N", ylabel="Convergence Rate", title="Convergence Rate of European Option Price", legend=false)
# Only plot errors
println("Plotting convergence of European option price...")
println(errors)
plot(grid_sizes, values(errors), xlabel="N", ylabel="Absolute Error", title="Convergence of European Option Price", legend=false)

## Kozpinar parameter set
PS_Kozpinar = HestonParams(S0=100.0, eff_mu = 0.04, r=0.05, kappa=1.0, theta=0.09, xi=0.4, rho=-0.7, v0=0.25)
K = 90.0
v_min, v_max, m = 0.001 * PS_Kozpinar.v0, 16.0 * PS_Kozpinar.v0, 10000
vgrid = collect(range(v_min, v_max, length=m))
Q = construct_generator_CIR(vgrid, PS_Kozpinar; tolerance=1e-5)

price_mc_koz = price_heston_ctmc_mc(PS_Kozpinar, vgrid, Q, T, K; npaths=1000)
